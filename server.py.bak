import os, json, time, uuid, logging, unicodedata
from functools import wraps
from typing import Optional
from flask import Flask, jsonify, request, g, make_response, has_request_context

try:
    from flask_cors import CORS
except Exception:
    CORS = None
try:
    from flask_limiter import Limiter
except Exception:
    Limiter = None

# ===== imports do domínio (use o pacote "meu_app") =====
from meu_app.models.cliente import Cliente
from meu_app.models.historico import HistoricoConversaPersistente
from meu_app.utils.openai_client import OpenAIClient
from meu_app.services.analisador import AnalisadorDeProblemas
from meu_app.services.buscador_pdf import BuscadorPDF
from meu_app.services.refinador import RefinadorResposta
from meu_app.services.atendimento import Atendimento
from meu_app.services.zapi_client import ZapiClient
from meu_app.services.conversor import ConversorPropostas
from meu_app.persistence.db import init_db, get_conn
from meu_app.persistence.repositories import (
    ClienteRepository,
    ContatoRepository,
    PropostaRepository,
)

# ===== logging json =====
def json_formatter(record: logging.LogRecord) -> str:
    base = {
        "ts": int(time.time() * 1000),
        "level": record.levelname,
        "msg": record.getMessage(),
        "logger": record.name,
    }
    rid = getattr(g, "request_id", None)
    if rid:
        base["request_id"] = rid
    path = getattr(request, "path", None)
    if path:
        base["path"] = path
        base["method"] = request.method
        base["remote_ip"] = request.headers.get("X-Forwarded-For", request.remote_addr)
    if record.exc_info:
        base["exc_info"] = True
    return json.dumps(base, ensure_ascii=False)

class _JSONHandler(logging.StreamHandler):
    def emit(self, record: logging.LogRecord) -> None:
        msg = json_formatter(record)
        self.stream.write(msg + "\n"); self.flush()

root = logging.getLogger()
root.handlers = [_JSONHandler()]
root.setLevel(logging.INFO)

# === PATCH: safe JSON logger ===
import logging, json, time
from flask import Flask, jsonify, request, g, make_response, has_request_context

def json_formatter(record: logging.LogRecord) -> str:
    base = {
        "ts": int(time.time()*1000),
        "level": record.levelname,
        "msg": record.getMessage(),
        "logger": record.name,
    }
    if has_request_context():
        try:
            rid = getattr(g, "request_id", None)
            if rid:
                base["request_id"] = rid
            base["path"] = request.path
            base["method"] = request.method
            base["remote_ip"] = request.headers.get("X-Forwarded-For", request.remote_addr)
        except Exception:
            pass
    if record.exc_info:
        base["exc_info"] = True
    return json.dumps(base, ensure_ascii=False)

class _JSONHandler(logging.StreamHandler):
    def emit(self, record: logging.LogRecord) -> None:
        try:
            msg = json_formatter(record)
        except Exception:
            msg = json.dumps({
                "ts": int(time.time()*1000),
                "level": record.levelname,
                "msg": record.getMessage(),
                "logger": record.name,
            }, ensure_ascii=False)
        self.stream.write(msg + "\n"); self.flush()

root = logging.getLogger()
root.handlers = [_JSONHandler()]
root.setLevel(logging.INFO)

# Logger do werkzeug separado, para não esbarrar no nosso handler no startup
wlog = logging.getLogger("werkzeug")
wlog.handlers = [logging.StreamHandler()]
wlog.setLevel(logging.INFO)
wlog.propagate = False
# === END PATCH ===
app = Flask(__name__)
log = app.logger; log.setLevel(logging.INFO)

# ===== CORS / Rate limit =====
allowed_origins = [o.strip() for o in os.getenv("ALLOWED_ORIGINS", "").split(",") if o.strip()]
if CORS and allowed_origins:
    CORS(app, resources={r"/*": {"origins": allowed_origins}})

limiter = None
if Limiter:
    limiter = Limiter(
        app=app,
        key_func=lambda: request.headers.get("X-Forwarded-For", request.remote_addr),
        default_limits=[os.getenv("RATE_LIMIT_DEFAULT", "60 per minute")],
    )

# ===== builders =====
def build_buscador() -> BuscadorPDF:
    return BuscadorPDF(
        openai_key=os.getenv("OPENAI_API_KEY"),
        tavily_key=os.getenv("TAVILY_API_KEY"),
        pdf_dir=os.getenv("PDFS_DIR", "data/pdfs"),
        index_dir=os.getenv("INDEX_DIR", "index/faiss_index"),
    )

def build_atendimento_for_phone(phone: str, sender_name: Optional[str] = None) -> Atendimento:
    init_db()
    cr = ClienteRepository(); ctr = ContatoRepository()
    contato = ctr.get_by_phone(phone)
    if contato:
        cid = contato["cliente_id"]
        data = cr.obter(cid); nome = data["nome"] if data else (sender_name or f"Contato {phone}")
        cliente = Cliente(nome); cliente.id = cid
    else:
        nome = sender_name or f"Contato {phone}"
        cliente = Cliente(nome)
        cr.criar(cliente.id, cliente.nome, cliente.data_criacao)
        ctr.upsert(phone, cliente.id, nome=cliente.nome)
    oai = OpenAIClient(api_key=os.getenv("OPENAI_API_KEY"))
    analisador = AnalisadorDeProblemas(oai)
    buscador = build_buscador()
    refinador = RefinadorResposta(oai)
    return Atendimento(cliente, analisador, buscador, refinador, historico=HistoricoConversaPersistente(cliente.id))

# ===== auth admin =====
def require_api_key(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        required = os.getenv("ADMIN_API_KEY")
        # aceita X-API-Key, Authorization: Bearer, ou ?api_key
        provided = (
            request.headers.get("X-API-Key")
            or (request.headers.get("Authorization", "").split(" ", 1)[-1] if request.headers.get("Authorization", "").lower().startswith("bearer ") else None)
            or request.args.get("api_key")
        )
        if not required:
            return jsonify({"error": "ADMIN_API_KEY não configurado"}), 500
        if not provided or provided != required:
            return jsonify({"error": "unauthorized"}), 401
        return fn(*args, **kwargs)
    return wrapper

metrics = {"requests_total": 0, "errors_total": 0}

# ===== request hooks =====
@app.before_request
def _before():
    g.request_id = request.headers.get("X-Request-Id") or uuid.uuid4().hex
    g.t0 = time.perf_counter()

@app.after_request
def _after(resp):
    resp.headers["X-Request-Id"] = g.get("request_id", "")
    dt = int((time.perf_counter() - g.get("t0", time.perf_counter())) * 1000)
    logging.getLogger("access").info(
        json.dumps(
            {
                "request_id": g.get("request_id"),
                "method": request.method,
                "path": request.path,
                "status": resp.status_code,
                "duration_ms": dt,
            },
            ensure_ascii=False,
        )
    )
    metrics["requests_total"] += 1
    if resp.status_code >= 400:
        metrics["errors_total"] += 1
    return resp

# ===== health/metrics =====
@app.route("/health")
def health():
    checks = {}
    try:
        with get_conn() as conn:
            conn.execute("SELECT 1")
        checks["db"] = "ok"
    except Exception as e:
        checks["db"] = f"error: {e}"
    has_index = os.path.exists(os.path.join(os.getenv("INDEX_DIR", "index/faiss_index"), "index.faiss"))
    checks["faiss_index"] = "present" if has_index else "absent"
    checks["openai_key"] = "set" if os.getenv("OPENAI_API_KEY") else "missing"
    status = 200 if checks["db"] == "ok" else 500
    return jsonify({"status": "ok" if status == 200 else "degraded", "checks": checks}), status

@app.route("/metrics")
def metrics_route():
    body = (
        "# HELP app_requests_total Total de requests\n"
        "# TYPE app_requests_total counter\n"
        f"app_requests_total {metrics['requests_total']}\n"
        "# HELP app_errors_total Total de erros\n"
        "# TYPE app_errors_total counter\n"
        f"app_errors_total {metrics['errors_total']}\n"
    )
    resp = make_response(body, 200)
    resp.headers["Content-Type"] = "text/plain; version=0.0.4"
    return resp

# ===== admin: índice =====
@app.route("/update-index", methods=["POST", "GET"])
@require_api_key
def update_index():
    if limiter:
        limiter.limit(os.getenv("RATE_LIMIT_ADMIN", "10 per minute"))(lambda: None)()
    buscador = build_buscador()
    m = buscador.atualizar_indice_verbose()
    return jsonify(m), 200

@app.route("/rebuild-index", methods=["POST", "GET"])
@require_api_key
def rebuild_index():
    if limiter:
        limiter.limit(os.getenv("RATE_LIMIT_ADMIN", "10 per minute"))(lambda: None)()
    buscador = build_buscador()
    m = buscador.indexador.indexar_pdfs()
    return jsonify(m), 200

# ===== Z-API: configurar webhooks =====
@app.route("/zapi/configure-webhooks", methods=["POST"])
@require_api_key
def zapi_configure_webhooks():
    if limiter:
        limiter.limit(os.getenv("RATE_LIMIT_ADMIN", "10 per minute"))(lambda: None)()
    data = request.get_json(silent=True) or {}
    received_url = data.get("received_url") or os.getenv("ZAPI_WEBHOOK_RECEIVED_URL")
    delivery_url = data.get("delivery_url") or os.getenv("ZAPI_WEBHOOK_DELIVERY_URL")
    if not received_url:
        return jsonify({"error": "Informe 'received_url'"}), 400
    zc = ZapiClient()
    out = {"received": zc.update_webhook_received(received_url)}
    if delivery_url:
        out["delivery"] = zc.update_webhook_delivery(delivery_url)
    return jsonify(out), 200

# ===== atendimento: ask =====
@app.route("/ask", methods=["POST"])
def ask():
    data = request.get_json(force=True) or {}
    pergunta = data.get("pergunta") or ""
    phone = str(data.get("phone") or "0000000000")
    nome = data.get("nome") or "Cliente API"
    if not pergunta:
        return jsonify({"error": "Campo 'pergunta' é obrigatório"}), 400
    atendimento = build_atendimento_for_phone(phone, nome)
    resposta = atendimento.receber_mensagem(pergunta)
    return jsonify({"resposta": resposta}), 200

# ===== helpers: detecção de aceite =====
def _normalize_text(s: str) -> str:
    s = s or ""
    s = "".join(c for c in unicodedata.normalize("NFD", s) if unicodedata.category(c) != "Mn")
    return s.lower().strip()

def _is_aceite_text(msg: str) -> bool:
    m = _normalize_text(msg)
    gatilhos = [
        "aceito", "fechado", "vamos fechar", "ok pode seguir", "pode seguir",
        "contratar", "concordo", "vamos sim", "ok, pode ser", "podemos seguir",
    ]
    return any(g in m for g in gatilhos)

# ===== webhook de recebimento (WhatsApp → Z-API) =====
@app.route("/zapi/webhook/received", methods=["POST"])
def zapi_webhook_received():
    if limiter:
        limiter.limit(os.getenv("RATE_LIMIT_WEBHOOK", "60 per minute"))(lambda: None)()
    try:
        payload = request.get_json(force=True) or {}
    except Exception as e:
        log.exception("bad json: %s", e)
        return jsonify({"status": "invalid json"}), 400

    phone = str(payload.get("phone") or payload.get("chatId") or "").strip()
    msg = payload.get("message") or payload.get("text") or ""
    sender_name = payload.get("senderName") or payload.get("sender") or None
    message_id = payload.get("messageId")

    # batelada
    if not phone or not msg:
        msgs = payload.get("messages")
        if isinstance(msgs, list) and msgs:
            item = msgs[0]
            phone = str(item.get("phone") or item.get("chatId") or "").strip() or phone
            msg = item.get("message") or item.get("text") or msg
            sender_name = item.get("senderName") or sender_name
            message_id = item.get("messageId") or message_id

    if not phone or not msg:
        return jsonify({"status": "ignored", "reason": "missing phone or message"}), 200

    atendimento = build_atendimento_for_phone(phone, sender_name)
    resposta = atendimento.receber_mensagem(msg)

    # responde
    status = "sent"
    try:
        ZapiClient().send_text(phone, resposta, reply_to_message_id=message_id)
    except Exception as e:
        log.exception("send_text error: %s", e)
        status = f"error: {e}"

    # detecção de ACEITE
    try:
        if _is_aceite_text(msg):
            repo = PropostaRepository()
            proposta = repo.ultima_enviada_do_cliente(atendimento.cliente.id)
            if proposta and proposta.get("status") != "accepted":
                repo.marcar_aceita(proposta["id"])
                try:
                    ZapiClient().send_text(
                        phone,
                        "Perfeito! Confirmamos o aceite. Vou te enviar o link de pagamento na sequência. ✅",
                    )
                except Exception as e2:
                    log.warning("Aviso pós-aceite falhou: %s", e2)
    except Exception as e:
        log.exception("Erro ao processar aceite automático: %s", e)

    return jsonify({"status": status}), 200

# ===== conversão: gerar e enviar proposta =====
@app.route("/conversao/proposta", methods=["POST"])
@require_api_key
def conversao_proposta():
    """
    body:
      - phone (E.164)  [obrigatório]
      - nome           [opcional]
      - resumo         [ou]
      - pergunta       [ou]
      - valor_economico_brl (float) [opcional]
    """
    data = request.get_json(force=True) or {}
    phone = str(data.get("phone") or "").strip()
    nome = data.get("nome") or "Cliente"
    resumo = (data.get("resumo") or "").strip()
    pergunta = (data.get("pergunta") or "").strip()

    valor = data.get("valor_economico_brl", data.get("valor"))
    try:
        valor_float = float(valor) if valor is not None else None
    except Exception:
        valor_float = None

    if not phone:
        return jsonify({"error": "Informe 'phone' no formato E.164 (ex.: 5511999999999)"}), 400

    atendimento = build_atendimento_for_phone(phone, nome)

    # Se vier pergunta e não resumo, gera um resumo com o analisador
    if pergunta and not resumo:
        anal = AnalisadorDeProblemas(OpenAIClient(os.getenv("OPENAI_API_KEY")))
        a = anal.analisar(pergunta)
        resumo = a.get("resumo") or pergunta

    if not resumo:
        return jsonify({"error": "Informe 'resumo' ou 'pergunta'"}), 400

    conversor = ConversorPropostas(OpenAIClient(os.getenv("OPENAI_API_KEY")), build_buscador())
    out = conversor.criar_e_enviar(
        atendimento.cliente.id,
        atendimento.cliente.nome,
        phone,
        resumo,
        valor_economico_brl=valor_float,
    )
    return jsonify(out), 200

# ===== conversão: marcar aceite manual =====
@app.route("/conversao/aceite", methods=["POST"])
def conversao_aceite():
    data = request.get_json(force=True) or {}
    proposta_id = data.get("proposta_id")
    if not proposta_id:
        return jsonify({"error": "Informe 'proposta_id'"}), 400
    repo = PropostaRepository()
    if not repo.obter(proposta_id):
        return jsonify({"error": "Proposta não encontrada"}), 404
    repo.marcar_aceita(proposta_id)
    return jsonify({"status": "accepted", "proposta_id": proposta_id}), 200
# ===== Z-API: rotas compatíveis/fallbacks =====
# Algumas contas/versões de Z-API postam em /webhook (sem prefixo).
# Encaminhamos para o handler já existente de "received".
@app.route("/webhook", methods=["POST"])
def webhook_alias():
    return zapi_webhook_received()

# (Opcional) Caso você configure também webhook de delivery,
# exponha essa rota para não responder 404.
@app.route("/zapi/webhook/delivery", methods=["POST"])
def zapi_webhook_delivery():
    try:
        if limiter:
            limiter.limit(os.getenv("RATE_LIMIT_WEBHOOK", "60 per minute"))(lambda: None)()
    except Exception:
        pass
    # Se quiser, registre o payload para auditoria:
    try:
        payload = request.get_json(force=True) or {}
        app.logger.info("delivery webhook: %s", json.dumps(payload, ensure_ascii=False))
    except Exception:
        pass
    return jsonify({"status": "ok"}), 200
# ===== fim rotas compatíveis =====
# ===== main =====
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", "5000")))



